import type { Stainless } from "@stainless-api/sdk";
import { Outcomes } from "./runBuilds";
import * as MD from "./markdown";
import { createCommentClient, getCITerm, getPRTerm } from "./compat";

const COMMENT_TITLE = MD.Heading(
  `${MD.Symbol.HeavyAsterisk} Stainless preview builds`,
);

const COMMENT_FOOTER_DIVIDER = MD.Comment("stainless-preview-footer");

type PrintCommentOptions = {
  noChanges: boolean;
  orgName: string;
  projectName: string;
  branch: string;
  commitMessage: string;
  baseOutcomes?: Outcomes | null;
  outcomes: Outcomes;
};

export function printComment({
  noChanges,
  orgName,
  projectName,
  branch,
  commitMessage,
  baseOutcomes,
  outcomes,
}:
  | ({ noChanges?: never } & Omit<PrintCommentOptions, "noChanges">)
  | ({ noChanges: true } & {
      [K in keyof Omit<PrintCommentOptions, "noChanges">]?: never;
    })) {
  const Blocks = (() => {
    if (noChanges) {
      return "No changes were made to the SDKs.";
    }
    // Can edit if this is a preview comment (and thus baseOutcomes exist).
    // Otherwise, this is post-merge and editing it won't do anything.
    const canEdit = !!baseOutcomes;

    return [
      MD.Dedent`
        This ${getPRTerm()} will update the ${MD.CodeInline(
          projectName,
        )} SDKs with the following commit message.

        ${MD.CodeBlock(commitMessage)}

        ${
          canEdit
            ? "Edit this comment to update it. It will appear in the SDK's changelogs."
            : ""
        }
      `,
      Results({ orgName, projectName, branch, outcomes, baseOutcomes }),
    ]
      .filter((f): f is string => f !== null)
      .join(`\n\n`);
  })();

  const fullComment = MD.Dedent`
    ${COMMENT_TITLE}

    ${Blocks}

    ${MD.Rule()}

    ${COMMENT_FOOTER_DIVIDER}

    ${MD.Italic(
      `This comment is auto-generated by ${getCITerm()} and is automatically kept up to date as you push.<br/>Last updated: ${new Date()
        .toISOString()
        .replace("T", " ")
        .replace(/\.\d+Z$/, " UTC")}`,
    )}
  `;

  return fullComment;
}

type DiagnosticLevel =
  Stainless.Builds.Diagnostics.DiagnosticListResponse["level"];

const DiagnosticIcon: Record<DiagnosticLevel, string> = {
  fatal: MD.Symbol.Exclamation,
  error: MD.Symbol.Exclamation,
  warning: MD.Symbol.Warning,
  note: MD.Symbol.Bulb,
};

function Results({
  orgName,
  projectName,
  branch,
  outcomes,
  baseOutcomes,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  outcomes: Outcomes;
  baseOutcomes?: Outcomes | null;
}): string {
  const results: string[] = [];
  let hasPending = false;

  // Process each outcome
  Object.entries(outcomes).forEach(([lang, head]) => {
    const base = baseOutcomes?.[lang];

    // Check if this outcome is pending
    if (categorize(head, base) === "pending") {
      hasPending = true;
    }

    // Get the formatted result for this outcome
    const result = Result({
      orgName,
      projectName,
      branch,
      lang,
      head,
      base,
    });

    if (result) {
      results.push(result);
    }
  });

  // Add pending message if any outcomes are pending
  if (hasPending) {
    results.push(
      MD.Dedent`
        ${MD.Symbol.HourglassFlowingSand} These are partial results; builds are still running.
      `,
    );
  }

  return results.join("\n\n");
}

function Result({
  orgName,
  projectName,
  branch,
  lang,
  head,
  base,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  lang: string;
  head: Outcomes[string];
  base?: Outcomes[string];
}): string | null {
  const category = categorize(head, base);

  const Description = (() => {
    switch (category) {
      case "failure": {
        switch (head.commit?.completed?.conclusion) {
          case "fatal":
            return MD.Italic(
              "Code was not generated because there was a fatal error.",
            );
          case "timed_out":
            return MD.Italic("Timed out.");
          default:
            return MD.Italic(
              `Unknown conclusion (${MD.CodeInline(
                head.commit?.completed?.conclusion || "unknown",
              )}).`,
            );
        }
      }
      case "merge_conflict":
        return [
          head.commit?.completed?.conclusion === "upstream_merge_conflict"
            ? MD.Italic(
                `There was an upstream conflict which is preventing the preview of your change.`,
              )
            : MD.Italic(
                `There was a conflict between your custom code and your generated changes.`,
              ),

          MD.Italic(
            `You don't need to resolve this conflict right now, but you will need to resolve it for your changes to be released to your users. ` +
              `Read more about why this happened ${MD.Link({
                text: "here",
                href: "https://www.stainless.com/docs/guides/add-custom-code",
              })}.`,
          ),
        ].join("\n");
      case "regression": {
        return MD.Italic("There was a regression in your SDK.");
      }
      case "success": {
        return MD.Italic("Your SDK built successfully.");
      }
      default:
        return "";
    }
  })();

  return MD.Details({
    summary: [
      ResultIcon(category),
      MD.Bold(`${projectName}-${lang}`),

      [
        MD.Link({
          text: "studio",
          href: `https://app.stainless.com/${orgName}/${projectName}/studio?language=${lang}&branch=${branch}`,
        }),
        GitHubLink(head),
        base ? CompareLink(base, head) : null,
        MergeConflictLink(head),
      ]
        .filter((link): link is string => link !== null)
        .join(` ${MD.Symbol.MiddleDot} `),
    ].join(" "),
    body: [
      Description,
      StatusLine(base, head),
      InstallationDetails(head, lang),
      base ? DiagnosticsDetails(head, base) : null,
    ]
      .filter((value): value is NonNullable<typeof value> => Boolean(value))
      .join("\n"),
    open: category !== "success" && category !== "pending",
  });
}

function ResultIcon(category: OutcomeCategory): string {
  switch (category) {
    case "failure":
      return MD.Symbol.Exclamation;
    case "merge_conflict":
      return MD.Symbol.Zap;
    case "regression":
      return MD.Symbol.Warning;
    case "success":
      return MD.Symbol.WhiteCheckMark;
    default:
      return MD.Symbol.HourglassFlowingSand;
  }
}

function StatusLine(
  base: Outcomes[string] | undefined,
  head: Outcomes[string],
): string {
  return [
    StatusStep(base, head, "generate"),
    StatusStep(base, head, "build"),
    StatusStep(base, head, "lint"),
    StatusStep(base, head, "test"),
  ]
    .filter((value): value is NonNullable<typeof value> => Boolean(value))
    .join(` ${MD.Symbol.RightwardsArrow} `);
}

function StatusStep(
  base: Outcomes[string] | undefined,
  head: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
): string | null {
  let baseStatus = base ? StatusSymbol(base, step) : null;
  let headStatus = StatusSymbol(head, step);

  if (!headStatus) {
    return null;
  }

  // If one of them is pending, both of them should look pending:
  if (
    baseStatus === MD.Symbol.HourglassFlowingSand ||
    headStatus === MD.Symbol.HourglassFlowingSand
  ) {
    baseStatus = MD.Symbol.HourglassFlowingSand;
    headStatus = MD.Symbol.HourglassFlowingSand;
  }

  const headText = MD.CodeInline(`${step} ${headStatus}`);
  const headURL = StatusURL(head, step);
  const headLink = headURL
    ? MD.Link({ text: headText, href: headURL })
    : headText;

  if (!baseStatus || baseStatus === headStatus) {
    return headLink;
  }

  const baseText = MD.CodeInline(`${step} ${baseStatus}`);
  const baseURL = StatusURL(base!, step);
  const baseLink = baseURL
    ? MD.Link({ text: baseText, href: baseURL })
    : baseText;

  return `${headLink} (prev: ${baseLink})`;
}

function StatusSymbol(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
) {
  if (!outcome.commit?.completed?.commit) {
    return null;
  }

  if (step === "generate") {
    switch (outcome.commit.completed.conclusion) {
      case "fatal":
      case "error":
      case "cancelled":
        return MD.Symbol.Exclamation;
      case "merge_conflict":
        return MD.Symbol.Zap;
      case "upstream_merge_conflict":
      case "warning":
        return MD.Symbol.Warning;
      default:
        return MD.Symbol.WhiteCheckMark;
    }
  }

  const stepData = outcome[step];
  if (!stepData) {
    return null;
  }

  if (stepData.status === "completed") {
    return stepData.completed.conclusion === "success"
      ? MD.Symbol.WhiteCheckMark
      : MD.Symbol.Exclamation;
  }

  return MD.Symbol.HourglassFlowingSand;
}

function StatusURL(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
) {
  if (
    step === "generate" ||
    !outcome[step] ||
    outcome[step].status !== "completed"
  ) {
    return null;
  }

  return outcome[step]?.completed?.url;
}

type OutcomeCategory =
  | "failure"
  | "merge_conflict"
  | "regression"
  | "success"
  | "pending";

function GitHubLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit?.completed?.commit) return null;

  const {
    repo: { owner, name, branch },
  } = outcome.commit.completed.commit;
  return MD.Link({
    text: "code",
    href: process.env.GITLAB_STAGING_REPO_PATH
      ? `https://gitlab.com/${process.env.GITLAB_STAGING_REPO_PATH}/tree/${encodeURIComponent(
          branch,
        )}`
      : `https://github.com/${owner}/${name}/tree/${encodeURIComponent(
          branch,
        )}`,
  });
}

function CompareLink(
  base: Outcomes[string],
  head: Outcomes[string],
): string | null {
  if (!base.commit?.completed?.commit || !head.commit?.completed?.commit) {
    return null;
  }

  const { repo } = head.commit.completed.commit;
  const baseBranch = base.commit.completed.commit.repo.branch;
  const headBranch = head.commit.completed.commit.repo.branch;
  const compareURL = process.env.GITLAB_STAGING_REPO_PATH
    ? `https://gitlab.com/${process.env.GITLAB_STAGING_REPO_PATH}/compare/${baseBranch}...${headBranch}`
    : `https://github.com/${repo.owner}/${repo.name}/compare/${baseBranch}..${headBranch}`;
  return MD.Link({ text: "diff", href: compareURL });
}

function MergeConflictLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit?.completed?.merge_conflict_pr) return null;

  const {
    repo: { owner, name },
    number,
  } = outcome.commit.completed.merge_conflict_pr;

  return MD.Link({
    text: "conflict",
    href: `https://github.com/${owner}/${name}/pull/${number}`,
  });
}

const diagnosticLevels = ["fatal", "error", "warning", "note"] as const;

function DiagnosticsDetails(
  head: Outcomes[string],
  base: Outcomes[string],
): string | null {
  if (!base.diagnostics || !head.diagnostics) return null;

  const newDiagnostics = head.diagnostics.filter(
    (d) =>
      !base.diagnostics.some(
        (bd) =>
          bd.code === d.code &&
          bd.message === d.message &&
          bd.config_ref === d.config_ref &&
          bd.oas_ref === d.oas_ref,
      ),
  );

  if (newDiagnostics.length === 0) return null;

  const levelCounts: Record<DiagnosticLevel, number> = {
    fatal: 0,
    error: 0,
    warning: 0,
    note: 0,
  };

  for (const d of newDiagnostics) {
    levelCounts[d.level]++;
  }

  const diagnosticCounts = Object.entries(levelCounts)
    .filter(([, count]) => count > 0)
    .map(([level, count]) => `${count} ${level}`);

  const diagnosticList = newDiagnostics
    .sort(
      (a, b) =>
        diagnosticLevels.indexOf(a.level) - diagnosticLevels.indexOf(b.level),
    )
    .slice(0, 10)
    .map((d) => `${DiagnosticIcon[d.level]} ${MD.Bold(d.code)}: ${d.message}`)
    .filter(Boolean) as string[];

  const tableRows = diagnosticList
    .map((diagnostic) => `<tr>\n<td>${diagnostic}</td>\n</tr>`)
    .join("\n");
  const tableContent = `<table>\n${tableRows}\n</table>`;

  return MD.Details({
    summary: `New diagnostics (${diagnosticCounts.join(", ")})`,
    body: tableContent,
    indent: false,
  });
}

function InstallationDetails(
  head: Outcomes[string],
  lang: string,
): string | null {
  let githubGoURL: string | null = null;
  let installation: string | null = null;

  if (head.commit?.completed.commit) {
    const { repo, sha } = head.commit.completed.commit;
    githubGoURL = `github.com/${repo.owner}/${repo.name}@${sha}`;
  }

  switch (lang) {
    case "typescript":
    case "node": {
      if (head.install_url) {
        installation = `npm install ${head.install_url}`;
      }
      break;
    }
    case "python": {
      if (head.install_url) {
        installation = `pip install ${head.install_url}`;
      }
      break;
    }
    case "go": {
      if (githubGoURL) {
        installation = `go get ${githubGoURL}`;
      }
      break;
    }
    default: {
      return null;
    }
  }

  if (!installation) return null;
  return MD.CodeBlock({ content: installation, language: "bash" });
}

function categorize(
  head: Outcomes[string],
  base?: Outcomes[string],
): OutcomeCategory {
  if (head.commit?.status !== "completed") {
    return "pending";
  }

  // Check for fatal failures first
  switch (head.commit.completed.conclusion) {
    case "fatal":
    case "timed_out":
      return "failure";
    case "merge_conflict":
    case "upstream_merge_conflict":
      return "merge_conflict";
    case "noop":
      return "success";
    // Completed success outcomes are handled below
    case "error":
    case "warning":
    case "note":
    case "success": {
      break;
    }
    // Unknown conclusions are fatal
    default:
      return "failure";
  }

  // Check if any step failed that previously succeeded or didn't exist
  for (const check of ["build", "lint", "test"] as const) {
    if (
      (!base?.[check] ||
        (base[check]?.status === "completed" &&
          base[check]?.completed.conclusion === "success")) &&
      head[check] &&
      head[check].status === "completed" &&
      head[check].completed.conclusion !== "success"
    ) {
      return "regression";
    }
  }

  // Check for new diagnostics that indicate regression
  if (base?.diagnostics && head.diagnostics) {
    const newDiagnostics = head.diagnostics.filter(
      (d) =>
        !base.diagnostics.some(
          (bd) =>
            bd.code === d.code &&
            bd.message === d.message &&
            bd.config_ref === d.config_ref &&
            bd.oas_ref === d.oas_ref,
        ),
    );

    if (
      newDiagnostics.some((d) =>
        ["fatal", "error", "warning"].includes(d.level),
      )
    ) {
      return "regression";
    }
  }

  // Check for pending steps
  for (const step of ["build", "lint", "test"] as const) {
    const stepData = head[step];
    if (stepData && stepData.status !== "completed") {
      return "pending";
    }
  }

  return "success";
}

export function parseCommitMessage(body?: string | null) {
  return body?.match(/(?<!\\)```([\s\S]*?)(?<!\\)```/)?.[1].trim() ?? null;
}

export async function retrieveComment({
  token,
  prNumber,
}: {
  token: string;
  prNumber: number;
}) {
  const client = createCommentClient(token, prNumber);
  const comments = await client.listComments();

  const existingComment =
    comments.find((comment) => comment.body?.includes(COMMENT_TITLE)) ?? null;

  return {
    id: existingComment?.id,
    commitMessage: parseCommitMessage(existingComment?.body),
  };
}

export async function upsertComment({
  body,
  token,
  prNumber,
  skipCreate = false,
}: {
  body: string;
  token: string;
  prNumber: number;
  skipCreate?: boolean;
}) {
  const client = createCommentClient(token, prNumber);

  console.log(`Upserting comment on ${getPRTerm()}:`, prNumber);

  const comments = await client.listComments();

  const firstLine = body.trim().split("\n")[0];
  const existingComment = comments.find((comment) =>
    comment.body?.includes(firstLine),
  );

  if (existingComment) {
    console.log("Updating existing comment:", existingComment.id);
    await client.updateComment(existingComment.id, body);
  } else if (!skipCreate) {
    console.log("Creating new comment");
    await client.createComment(body);
  }
}

function areCommentsEqual(a: string, b: string) {
  // Need to ignore the timestamp lines.
  return (
    a.slice(0, a.indexOf(COMMENT_FOOTER_DIVIDER)) ===
    b.slice(0, b.indexOf(COMMENT_FOOTER_DIVIDER))
  );
}

export function commentThrottler(token: string, prNumber: number) {
  let lastComment: string | null = null;
  let lastCommentTime: Date | null = null;

  return async ({ body, force = false }: { body: string; force?: boolean }) => {
    if (
      force ||
      !lastComment ||
      !lastCommentTime ||
      (!areCommentsEqual(body, lastComment) &&
        Date.now() - lastCommentTime.getTime() > 10 * 1000) ||
      Date.now() - lastCommentTime.getTime() > 30 * 1000
    ) {
      await upsertComment({ body, token, prNumber });
      lastComment = body;
      lastCommentTime = new Date();
    }
  };
}
