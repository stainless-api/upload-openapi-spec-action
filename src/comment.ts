import {
  createCommentClient,
  getCITerm,
  getPRTerm,
  getRepoPath,
} from "./compat";
import * as MD from "./markdown";
import type { DiagnosticLevel, Outcomes } from "./outcomes";
import {
  categorizeOutcome,
  countDiagnosticLevels,
  getNewDiagnostics,
  sortDiagnostics,
} from "./outcomes";

const COMMENT_TITLE = MD.Heading(
  `${MD.Symbol.HeavyAsterisk} Stainless preview builds`,
);

const COMMENT_FOOTER_DIVIDER = MD.Comment("stainless-preview-footer");

type PrintCommentOptions = {
  noChanges: boolean;
  orgName: string;
  projectName: string;
  branch: string;
  commitMessage: string;
  baseOutcomes?: Outcomes | null;
  outcomes: Outcomes;
};

export function printComment({
  noChanges,
  orgName,
  projectName,
  branch,
  commitMessage,
  baseOutcomes,
  outcomes,
}:
  | ({ noChanges?: never } & Omit<PrintCommentOptions, "noChanges">)
  | ({ noChanges: true } & {
      [K in keyof Omit<PrintCommentOptions, "noChanges">]?: never;
    })) {
  const Blocks = (() => {
    if (noChanges) {
      return "No changes were made to the SDKs.";
    }
    // Can edit if this is a preview comment (and thus baseOutcomes exist).
    // Otherwise, this is post-merge and editing it won't do anything.
    const canEdit = !!baseOutcomes;

    return [
      MD.Dedent`
        This ${getPRTerm()} will update the ${MD.CodeInline(
          projectName,
        )} SDKs with the following commit message.

        ${MD.CodeBlock(commitMessage)}

        ${
          canEdit
            ? "Edit this comment to update it. It will appear in the SDK's changelogs."
            : ""
        }
      `,
      Results({ orgName, projectName, branch, outcomes, baseOutcomes }),
    ]
      .filter((f): f is string => f !== null)
      .join(`\n\n`);
  })();

  const fullComment = MD.Dedent`
    ${COMMENT_TITLE}

    ${Blocks}

    ${MD.Rule()}

    ${COMMENT_FOOTER_DIVIDER}

    ${MD.Italic(
      `This comment is auto-generated by ${getCITerm()} and is automatically kept up to date as you push.<br/>Last updated: ${new Date()
        .toISOString()
        .replace("T", " ")
        .replace(/\.\d+Z$/, " UTC")}`,
    )}
  `;

  return fullComment;
}

const DiagnosticIcon: Record<DiagnosticLevel, string> = {
  fatal: MD.Symbol.Exclamation,
  error: MD.Symbol.Exclamation,
  warning: MD.Symbol.Warning,
  note: MD.Symbol.Bulb,
};

function Results({
  orgName,
  projectName,
  branch,
  outcomes,
  baseOutcomes,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  outcomes: Outcomes;
  baseOutcomes?: Outcomes | null;
}): string {
  const results: string[] = [];
  let hasPending = false;

  // Process each outcome
  Object.entries(outcomes).forEach(([lang, head]) => {
    const base = baseOutcomes?.[lang];

    // Check if this outcome is pending
    hasPending ||=
      categorizeOutcome({
        outcome: head,
        baseOutcome: base,
      }).isPending ?? false;

    // Get the formatted result for this outcome
    const result = Result({
      orgName,
      projectName,
      branch,
      lang,
      head,
      base,
    });

    if (result) {
      results.push(result);
    }
  });

  // Add pending message if any outcomes are pending
  if (hasPending) {
    results.push(
      MD.Dedent`
        ${MD.Symbol.HourglassFlowingSand} These are partial results; builds are still running.
      `,
    );
  }

  return results.join("\n\n");
}

function Result({
  orgName,
  projectName,
  branch,
  lang,
  head,
  base,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  lang: string;
  head: Outcomes[string];
  base?: Outcomes[string];
}): string | null {
  const { conclusion, reason, isMergeConflict, isPending } = categorizeOutcome({
    outcome: head,
    baseOutcome: base,
  });

  const { ResultIcon, Description } = (() => {
    if (conclusion === "fatal") {
      return {
        ResultIcon: MD.Symbol.Exclamation,
        Description: MD.Italic(reason),
      };
    }
    if (isMergeConflict) {
      return {
        ResultIcon: MD.Symbol.Zap,
        Description: [
          MD.Italic(reason),
          MD.Italic(
            `You don't need to resolve this conflict right now, but you will need to resolve it for your changes to be released to your users. ` +
              `Read more about why this happened ${MD.Link({
                text: "here",
                href: "https://www.stainless.com/docs/guides/add-custom-code",
              })}.`,
          ),
        ].join("\n"),
      };
    }
    if (conclusion !== "note" && conclusion !== "success") {
      return {
        ResultIcon: MD.Symbol.Warning,
        Description: MD.Italic("There was a regression in your SDK."),
      };
    }
    if (!isPending) {
      return {
        ResultIcon: MD.Symbol.WhiteCheckMark,
        Description: MD.Italic("Your SDK built successfully."),
      };
    }
    return {
      ResultIcon: MD.Symbol.HourglassFlowingSand,
      Description: "",
    };
  })();

  return MD.Details({
    summary: [
      ResultIcon,
      MD.Bold(`${projectName}-${lang}`),

      [
        MD.Link({
          text: "studio",
          href: `https://app.stainless.com/${orgName}/${projectName}/studio?language=${lang}&branch=${branch}`,
        }),
        GitHubLink(head),
        base ? CompareLink(base, head) : null,
        MergeConflictLink(head),
      ]
        .filter((link): link is string => link !== null)
        .join(` ${MD.Symbol.MiddleDot} `),
    ].join(" "),
    body: [
      Description,
      StatusLine(base, head),
      InstallationDetails(head, lang),
      base ? DiagnosticsDetails(head, base) : null,
    ]
      .filter((value): value is NonNullable<typeof value> => Boolean(value))
      .join("\n"),
    open: conclusion !== "note" && conclusion !== "success" && !isPending,
  });
}

function StatusLine(
  base: Outcomes[string] | undefined,
  head: Outcomes[string],
): string {
  return [
    StatusStep(base, head, "generate"),
    StatusStep(base, head, "build"),
    StatusStep(base, head, "lint"),
    StatusStep(base, head, "test"),
  ]
    .filter((value): value is NonNullable<typeof value> => Boolean(value))
    .join(` ${MD.Symbol.RightwardsArrow} `);
}

function StatusStep(
  base: Outcomes[string] | undefined,
  head: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
): string | null {
  let baseStatus = base ? StatusSymbol(base, step) : null;
  let headStatus = StatusSymbol(head, step);

  if (!headStatus) {
    return null;
  }

  // If one of them is pending, both of them should look pending:
  if (
    baseStatus === MD.Symbol.HourglassFlowingSand ||
    headStatus === MD.Symbol.HourglassFlowingSand
  ) {
    baseStatus = MD.Symbol.HourglassFlowingSand;
    headStatus = MD.Symbol.HourglassFlowingSand;
  }

  const headText = MD.CodeInline(`${step} ${headStatus}`);
  const headURL = StatusURL(head, step);
  const headLink = headURL
    ? MD.Link({ text: headText, href: headURL })
    : headText;

  if (!baseStatus || baseStatus === headStatus) {
    return headLink;
  }

  const baseText = MD.CodeInline(`${step} ${baseStatus}`);
  const baseURL = StatusURL(base!, step);
  const baseLink = baseURL
    ? MD.Link({ text: baseText, href: baseURL })
    : baseText;

  return `${headLink} (prev: ${baseLink})`;
}

function StatusSymbol(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
) {
  if (!outcome.commit?.completed?.commit) {
    return null;
  }

  if (step === "generate") {
    switch (outcome.commit.completed.conclusion) {
      case "fatal":
      case "error":
      case "cancelled":
        return MD.Symbol.Exclamation;
      case "merge_conflict":
        return MD.Symbol.Zap;
      case "upstream_merge_conflict":
      case "warning":
        return MD.Symbol.Warning;
      default:
        return MD.Symbol.WhiteCheckMark;
    }
  }

  const stepData = outcome[step];
  if (!stepData) {
    return null;
  }

  if (stepData.status === "completed") {
    return stepData.completed.conclusion === "success"
      ? MD.Symbol.WhiteCheckMark
      : MD.Symbol.Exclamation;
  }

  return MD.Symbol.HourglassFlowingSand;
}

function StatusURL(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
) {
  if (
    step === "generate" ||
    !outcome[step] ||
    outcome[step].status !== "completed"
  ) {
    return null;
  }

  return outcome[step]?.completed?.url;
}

function GitHubLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit?.completed?.commit) return null;

  const {
    repo: { owner, name, branch },
  } = outcome.commit.completed.commit;
  return MD.Link({
    text: "code",
    href: `${getRepoPath(owner, name)}/tree/${encodeURIComponent(branch)}`,
  });
}

function CompareLink(
  base: Outcomes[string],
  head: Outcomes[string],
): string | null {
  if (!base.commit?.completed?.commit || !head.commit?.completed?.commit) {
    return null;
  }

  const { repo } = head.commit.completed.commit;
  const baseBranch = base.commit.completed.commit.repo.branch;
  const headBranch = head.commit.completed.commit.repo.branch;
  const compareURL = `${getRepoPath(repo.owner, repo.name)}/compare/${baseBranch}..${headBranch}`;
  return MD.Link({ text: "diff", href: compareURL });
}

function MergeConflictLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit?.completed?.merge_conflict_pr) return null;

  const {
    repo: { owner, name },
    number,
  } = outcome.commit.completed.merge_conflict_pr;

  return MD.Link({
    text: "conflict",
    href: `https://github.com/${owner}/${name}/pull/${number}`,
  });
}

function DiagnosticsDetails(
  head: Outcomes[string],
  base: Outcomes[string],
): string | null {
  if (!base.diagnostics || !head.diagnostics) return null;

  const newDiagnostics = getNewDiagnostics(head.diagnostics, base.diagnostics);

  if (newDiagnostics.length === 0) return null;

  const levelCounts = countDiagnosticLevels(newDiagnostics);

  const diagnosticCounts = Object.entries(levelCounts)
    .filter(([, count]) => count > 0)
    .map(([level, count]) => `${count} ${level}`);

  const diagnosticList = sortDiagnostics(newDiagnostics)
    .slice(0, 10)
    .map((d) => `${DiagnosticIcon[d.level]} ${MD.Bold(d.code)}: ${d.message}`)
    .filter(Boolean) as string[];

  const tableRows = diagnosticList
    .map((diagnostic) => `<tr>\n<td>${diagnostic}</td>\n</tr>`)
    .join("\n");
  const tableContent = `<table>\n${tableRows}\n</table>`;

  return MD.Details({
    summary: `New diagnostics (${diagnosticCounts.join(", ")})`,
    body: tableContent,
    indent: false,
  });
}

function InstallationDetails(
  head: Outcomes[string],
  lang: string,
): string | null {
  let githubGoURL: string | null = null;
  let installation: string | null = null;

  if (head.commit?.completed.commit) {
    const { repo, sha } = head.commit.completed.commit;
    githubGoURL = `github.com/${repo.owner}/${repo.name}@${sha}`;
  }

  switch (lang) {
    case "typescript":
    case "node": {
      if (head.install_url) {
        installation = `npm install ${head.install_url}`;
      }
      break;
    }
    case "python": {
      if (head.install_url) {
        installation = `pip install ${head.install_url}`;
      }
      break;
    }
    case "go": {
      if (githubGoURL) {
        installation = `go get ${githubGoURL}`;
      }
      break;
    }
    default: {
      return null;
    }
  }

  if (!installation) return null;
  return MD.CodeBlock({ content: installation, language: "bash" });
}

export function parseCommitMessage(body?: string | null) {
  return body?.match(/(?<!\\)```([\s\S]*?)(?<!\\)```/)?.[1].trim() ?? null;
}

export async function retrieveComment({
  token,
  prNumber,
}: {
  token: string;
  prNumber: number;
}) {
  const client = createCommentClient(token, prNumber);
  const comments = await client.listComments();

  const existingComment =
    comments.find((comment) => comment.body?.includes(COMMENT_TITLE)) ?? null;

  return {
    id: existingComment?.id,
    commitMessage: parseCommitMessage(existingComment?.body),
  };
}

export async function upsertComment({
  body,
  token,
  prNumber,
  skipCreate = false,
}: {
  body: string;
  token: string;
  prNumber: number;
  skipCreate?: boolean;
}) {
  const client = createCommentClient(token, prNumber);

  console.log(`Upserting comment on ${getPRTerm()}:`, prNumber);

  const comments = await client.listComments();

  const firstLine = body.trim().split("\n")[0];
  const existingComment = comments.find((comment) =>
    comment.body?.includes(firstLine),
  );

  if (existingComment) {
    console.log("Updating existing comment:", existingComment.id);
    await client.updateComment(existingComment.id, body);
  } else if (!skipCreate) {
    console.log("Creating new comment");
    await client.createComment(body);
  }
}

function areCommentsEqual(a: string, b: string) {
  // Need to ignore the timestamp lines.
  return (
    a.slice(0, a.indexOf(COMMENT_FOOTER_DIVIDER)) ===
    b.slice(0, b.indexOf(COMMENT_FOOTER_DIVIDER))
  );
}

export function commentThrottler(token: string, prNumber: number) {
  let lastComment: string | null = null;
  let lastCommentTime: Date | null = null;

  return async ({ body, force = false }: { body: string; force?: boolean }) => {
    if (
      force ||
      !lastComment ||
      !lastCommentTime ||
      (!areCommentsEqual(body, lastComment) &&
        Date.now() - lastCommentTime.getTime() > 10 * 1000) ||
      Date.now() - lastCommentTime.getTime() > 30 * 1000
    ) {
      await upsertComment({ body, token, prNumber });
      lastComment = body;
      lastCommentTime = new Date();
    }
  };
}
