import { makeCommitMessageConventional } from "./commitMessage";
import { api, ctx } from "./compat";
import { logger } from "./logger";
import * as MD from "./markdown";
import type { DiagnosticLevel, Outcomes } from "./outcomes";
import {
  categorizeOutcome,
  countDiagnosticLevels,
  getNewDiagnostics,
  getReason,
  sortDiagnostics,
} from "./outcomes";

const COMMENT_TITLE = MD.Heading(
  `${MD.Symbol.HeavyAsterisk} Stainless preview builds`,
);

const COMMENT_FOOTER_DIVIDER = MD.Comment("stainless-preview-footer");

type PrintCommentOptions = {
  noChanges: boolean;
  orgName: string;
  projectName: string;
  branch: string;
  commitMessage: string;
  targetCommitMessages?: Record<string, string>;
  pendingAiCommitMessages?: Set<string>;
  baseOutcomes?: Outcomes | null;
  outcomes: Outcomes;
};

export function printComment({
  noChanges,
  orgName,
  projectName,
  branch,
  commitMessage,
  targetCommitMessages,
  pendingAiCommitMessages,
  baseOutcomes,
  outcomes,
}:
  | ({ noChanges?: never } & Omit<PrintCommentOptions, "noChanges">)
  | ({ noChanges: true } & {
      [K in keyof Omit<PrintCommentOptions, "noChanges">]?: never;
    })) {
  const Blocks = (() => {
    if (noChanges) {
      return "No changes were made to the SDKs.";
    }

    // Can edit if this is a preview comment (and thus baseOutcomes exist).
    // Otherwise, this is post-merge and editing it won't do anything.
    const canEdit = !!baseOutcomes;

    return [
      MD.Dedent`
        This ${ctx().names.pr} will update the ${MD.CodeInline(
          projectName,
        )} SDKs with the following commit ${targetCommitMessages ? "messages" : "message"}.
      `,
      targetCommitMessages
        ? CommitMessagesSection({
            targets: Object.keys(outcomes).sort(),
            pendingAiCommitMessages,
            targetCommitMessages,
            commitMessage,
          })
        : MD.CodeBlock(commitMessage),
      !canEdit
        ? null
        : targetCommitMessages
          ? "Edit this comment to update them. They will appear in their respective SDK's changelogs."
          : "Edit this comment to update it. It will appear in the SDK's changelogs.",
      Results({ orgName, projectName, branch, outcomes, baseOutcomes }),
    ]
      .filter((f): f is string => f !== null)
      .join(`\n\n`);
  })();

  const dateString = new Date()
    .toISOString()
    .replace("T", " ")
    .replace(/\.\d+Z$/, " UTC");

  const fullComment = MD.Dedent`
    ${COMMENT_TITLE}

    ${Blocks}

    ${MD.Rule()}

    ${COMMENT_FOOTER_DIVIDER}

    ${MD.Italic(
      `This comment is auto-generated by ${ctx().names.ci} and is automatically kept up to date as you push.<br/>` +
        `If you push custom code to the preview branch, ${MD.Link({
          text: `re-run this workflow`,
          href: ctx().urls.run,
        })} to update the comment.` +
        `<br/>Last updated: ${dateString}`,
    )}
  `;

  return fullComment;
}

function CommitMessagesSection({
  targets,
  pendingAiCommitMessages,
  targetCommitMessages,
  commitMessage,
}: {
  targets: string[];
  pendingAiCommitMessages?: Set<string>;
  targetCommitMessages: Record<string, string>;
  commitMessage: string;
}): string {
  return targets
    .map((target) => {
      const statusText = pendingAiCommitMessages?.has(target)
        ? `${MD.Symbol.HourglassFlowingSand} (generating...)`
        : "";
      const message = targetCommitMessages[target] ?? commitMessage;

      return MD.Dedent`
        **${target}**
        ${statusText}${MD.CodeBlock(message)}
      `;
    })
    .join("\n");
}

const DiagnosticIcon: Record<DiagnosticLevel, string> = {
  fatal: MD.Symbol.Exclamation,
  error: MD.Symbol.Exclamation,
  warning: MD.Symbol.Warning,
  note: MD.Symbol.Bulb,
};

function Results({
  orgName,
  projectName,
  branch,
  outcomes,
  baseOutcomes,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  outcomes: Outcomes;
  baseOutcomes?: Outcomes | null;
}): string {
  const results: string[] = [];
  let hasPending = false;

  // Process each outcome
  Object.entries(outcomes).forEach(([lang, head]) => {
    const base = baseOutcomes?.[lang];

    // Check if this outcome is pending
    hasPending ||=
      categorizeOutcome({
        outcome: head,
        baseOutcome: base,
      }).isPending ?? false;

    // Get the formatted result for this outcome
    const result = Result({
      orgName,
      projectName,
      branch,
      lang,
      head,
      base,
    });

    if (result) {
      results.push(result);
    }
  });

  // Add pending message if any outcomes are pending
  if (hasPending) {
    results.push(
      MD.Dedent`
        ${MD.Symbol.HourglassFlowingSand} These are partial results; builds are still running.
      `,
    );
  }

  return results.join("\n\n");
}

function Result({
  orgName,
  projectName,
  branch,
  lang,
  head,
  base,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  lang: string;
  head: Outcomes[string];
  base?: Outcomes[string];
}): string | null {
  const categorized = categorizeOutcome({
    outcome: head,
    baseOutcome: base,
  });

  const { ResultIcon, Description } = (() => {
    if (categorized.isPending) {
      return {
        ResultIcon: MD.Symbol.HourglassFlowingSand,
        Description: "",
      };
    }

    const { severity, conclusion, isRegression, description } = categorized;
    const reason = getReason({
      description,
      isRegression,
    });

    if (isRegression !== false && severity === "fatal") {
      return {
        ResultIcon: MD.Symbol.Exclamation,
        Description: MD.Italic(reason),
      };
    }
    if (isRegression !== false && conclusion === "merge_conflict") {
      return {
        ResultIcon: MD.Symbol.Zap,
        Description: [
          MD.Italic(reason),
          MD.Italic(
            `You don't need to resolve this conflict right now, but you will need to resolve it for your changes to be released to your users. ` +
              `Read more about why this happened ${MD.Link({
                text: "here",
                href: "https://www.stainless.com/docs/guides/add-custom-code",
              })}.`,
          ),
        ].join("\n"),
      };
    }
    if (isRegression !== false && severity !== "note" && severity !== null) {
      return {
        ResultIcon: MD.Symbol.Warning,
        Description: MD.Italic(reason),
      };
    }
    return {
      ResultIcon: MD.Symbol.WhiteCheckMark,
      Description: MD.Italic(reason),
    };
  })();

  return MD.Details({
    summary: [
      ResultIcon,
      MD.Bold(`${projectName}-${lang}`),

      [
        MD.Link({
          text: "studio",
          href: `https://app.stainless.com/${orgName}/${projectName}/studio?language=${lang}&branch=${branch}`,
        }),
        GitHubLink(head),
        base ? CompareLink(base, head) : null,
        MergeConflictLink(head),
      ]
        .filter((link): link is string => link !== null)
        .join(` ${MD.Symbol.MiddleDot} `),
    ].join(" "),
    body: [
      Description,
      StatusLine(base, head),
      InstallationDetails(head, lang),
      base ? DiagnosticsDetails(head, base) : null,
    ]
      .filter((value): value is NonNullable<typeof value> => Boolean(value))
      .join("\n"),
    open:
      !categorized.isPending &&
      categorized.isRegression !== false &&
      categorized.severity !== "note" &&
      categorized.severity !== null,
  });
}

function StatusLine(
  base: Outcomes[string] | undefined,
  head: Outcomes[string],
): string {
  return [
    StatusStep(base, head, "generate"),
    StatusStep(base, head, "build"),
    StatusStep(base, head, "lint"),
    StatusStep(base, head, "test"),
  ]
    .filter((value): value is NonNullable<typeof value> => Boolean(value))
    .join(` ${MD.Symbol.RightwardsArrow} `);
}

function StatusStep(
  base: Outcomes[string] | undefined,
  head: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
): string | null {
  let baseStatus = base ? StatusSymbol(base, step) : null;
  let headStatus = StatusSymbol(head, step);

  if (!headStatus) {
    return null;
  }

  // If one of them is pending, both of them should look pending:
  if (
    baseStatus === MD.Symbol.HourglassFlowingSand ||
    headStatus === MD.Symbol.HourglassFlowingSand
  ) {
    baseStatus = MD.Symbol.HourglassFlowingSand;
    headStatus = MD.Symbol.HourglassFlowingSand;
  }

  const headText = MD.CodeInline(`${step} ${headStatus}`);
  const headURL = StatusURL(head, step);
  const headLink = headURL
    ? MD.Link({ text: headText, href: headURL })
    : headText;

  if (!baseStatus || baseStatus === headStatus) {
    return headLink;
  }

  const baseText = MD.CodeInline(`${step} ${baseStatus}`);
  const baseURL = StatusURL(base!, step);
  const baseLink = baseURL
    ? MD.Link({ text: baseText, href: baseURL })
    : baseText;

  return `${headLink} (prev: ${baseLink})`;
}

function StatusSymbol(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
) {
  if (!outcome.commit?.completed?.commit) {
    return null;
  }

  if (step === "generate") {
    switch (outcome.commit.completed.conclusion) {
      case "fatal":
      case "error":
      case "cancelled":
        return MD.Symbol.Exclamation;
      case "merge_conflict":
        return MD.Symbol.Zap;
      case "upstream_merge_conflict":
      case "warning":
        return MD.Symbol.Warning;
      default:
        return MD.Symbol.WhiteCheckMark;
    }
  }

  const stepData = outcome[step];
  if (!stepData) {
    return null;
  }

  if (stepData.status === "completed") {
    return stepData.completed.conclusion === "success"
      ? MD.Symbol.WhiteCheckMark
      : stepData.completed.conclusion === "skipped"
        ? MD.Symbol.Skipped
        : MD.Symbol.Exclamation;
  }

  return MD.Symbol.HourglassFlowingSand;
}

function StatusURL(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
) {
  if (
    step === "generate" ||
    !outcome[step] ||
    outcome[step].status !== "completed"
  ) {
    return null;
  }

  return outcome[step]?.completed?.url;
}

function GitHubLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit?.completed?.commit) return null;

  const {
    repo: { owner, name, branch },
  } = outcome.commit.completed.commit;
  return MD.Link({
    text: "code",
    // This is a staging repo, so it's always GitHub.
    href: `https://github.com/${owner}/${name}/tree/${encodeURIComponent(branch)}`,
  });
}

function CompareLink(
  base: Outcomes[string],
  head: Outcomes[string],
): string | null {
  if (!base.commit?.completed?.commit || !head.commit?.completed?.commit) {
    return null;
  }

  const { repo } = head.commit.completed.commit;
  const baseBranch = base.commit.completed.commit.repo.branch;
  const headBranch = head.commit.completed.commit.repo.branch;
  // This is a staging repo, so it's always GitHub.
  const compareURL = `https://github.com/${repo.owner}/${repo.name}/compare/${baseBranch}..${headBranch}`;
  return MD.Link({ text: "diff", href: compareURL });
}

function MergeConflictLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit?.completed?.merge_conflict_pr) return null;

  const {
    repo: { owner, name },
    number,
  } = outcome.commit.completed.merge_conflict_pr;

  return MD.Link({
    text: "conflict",
    href: `https://github.com/${owner}/${name}/pull/${number}`,
  });
}

function DiagnosticsDetails(
  head: Outcomes[string],
  base: Outcomes[string],
): string | null {
  if (!base.diagnostics || !head.diagnostics) return null;

  const newDiagnostics = getNewDiagnostics(head.diagnostics, base.diagnostics);

  if (newDiagnostics.length === 0) return null;

  const levelCounts = countDiagnosticLevels(newDiagnostics);

  const diagnosticCounts = Object.entries(levelCounts)
    .filter(([, count]) => count > 0)
    .map(([level, count]) => `${count} ${level}`);

  const diagnosticList = sortDiagnostics(newDiagnostics)
    .slice(0, 10)
    .map((d) => `${DiagnosticIcon[d.level]} ${MD.Bold(d.code)}: ${d.message}`)
    .filter(Boolean) as string[];

  const tableRows = diagnosticList
    .map((diagnostic) => `<tr>\n<td>${diagnostic}</td>\n</tr>`)
    .join("\n");
  const tableContent = `<table>\n${tableRows}\n</table>`;

  return MD.Details({
    summary: `New diagnostics (${diagnosticCounts.join(", ")})`,
    body: tableContent,
    indent: false,
  });
}

function InstallationDetails(
  head: Outcomes[string],
  lang: string,
): string | null {
  let githubGoURL: string | null = null;
  let installation: string | null = null;

  if (head.commit?.completed.commit) {
    const { repo, sha } = head.commit.completed.commit;
    githubGoURL = `github.com/${repo.owner}/${repo.name}@${sha}`;
  }

  switch (lang) {
    case "typescript":
    case "node": {
      if (head.install_url) {
        installation = `npm install ${head.install_url}`;
      }
      break;
    }
    case "python": {
      if (head.install_url) {
        installation = `pip install ${head.install_url}`;
      }
      break;
    }
    case "go": {
      if (githubGoURL) {
        installation = `go get ${githubGoURL}`;
      }
      break;
    }
    case "java": {
      if (head.install_url) {
        installation = `Add the following URL as a Maven source: '${head.install_url}'`;
      }
      break;
    }
    case "cli": {
      if (head.install_url) {
        installation = `Download and unzip: '${head.install_url}'. On macOS, run \`xattr -d com.apple.quarantine {executable name}\`.`;
      }
      break;
    }
    default: {
      return null;
    }
  }

  if (!installation) return null;
  return MD.CodeBlock({ content: installation, language: "bash" });
}

export function parseCommitMessages(body?: string | null): {
  commitMessage?: string;
  targetCommitMessages?: Record<string, string>;
} {
  if (!body) {
    return {};
  }

  const targetCommitMessages: Record<string, string> = {};

  // Match pattern: **language**\n```\ncommit message\n```
  const languageBlocks = body.matchAll(
    /\*\*([a-z_]+)\*\*\s*\n```\s*\n([\s\S]*?)\n```/g,
  );

  for (const match of languageBlocks) {
    const language = match[1];
    const message = match[2].trim();
    if (message) {
      targetCommitMessages[language] = makeCommitMessageConventional(message);
    }
  }

  if (Object.keys(targetCommitMessages).length > 0) {
    return { targetCommitMessages };
  }

  const message = body?.match(/(?<!\\)```([\s\S]*?)(?<!\\)```/)?.[1].trim();
  return message
    ? { commitMessage: makeCommitMessageConventional(message) }
    : {};
}

export async function retrieveComment(prNumber: number) {
  const comments = await api().listComments(prNumber);

  const existingComment = comments.find((comment) =>
    comment.body?.includes(COMMENT_TITLE),
  );

  if (!existingComment) {
    return null;
  }

  return {
    id: existingComment.id,
    ...parseCommitMessages(existingComment.body),
  };
}

export async function upsertComment(
  prNumber: number,
  {
    body,
    skipCreate = false,
  }: {
    body: string;
    skipCreate?: boolean;
  },
) {
  logger.debug(`Upserting comment on ${ctx().names.pr} #${prNumber}`);

  const comments = await api().listComments(prNumber);

  const firstLine = body.trim().split("\n")[0];
  const existingComment = comments.find((comment) =>
    comment.body?.includes(firstLine),
  );

  if (existingComment) {
    logger.debug("Updating existing comment:", existingComment.id);
    await api().updateComment(prNumber, { ...existingComment, body });
  } else if (!skipCreate) {
    logger.debug("Creating new comment");
    await api().createComment(prNumber, { body });
  }
}

function areCommentsEqual(a: string, b: string) {
  // Need to ignore the timestamp lines.
  return (
    a.slice(0, a.indexOf(COMMENT_FOOTER_DIVIDER)) ===
    b.slice(0, b.indexOf(COMMENT_FOOTER_DIVIDER))
  );
}

export function commentThrottler(prNumber: number) {
  let lastComment: string | null = null;
  let lastCommentTime: Date | null = null;

  return async ({ body, force = false }: { body: string; force?: boolean }) => {
    if (
      force ||
      !lastComment ||
      !lastCommentTime ||
      (!areCommentsEqual(body, lastComment) &&
        Date.now() - lastCommentTime.getTime() > 10 * 1000) ||
      Date.now() - lastCommentTime.getTime() > 30 * 1000
    ) {
      await upsertComment(prNumber, { body });
      lastComment = body;
      lastCommentTime = new Date();
    }
  };
}
