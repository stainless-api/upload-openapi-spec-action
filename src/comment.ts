import {
  createVCSClient,
  getCITerm,
  getPRTerm,
  getRepoPath,
  getRunUrl,
} from "./compat";
import { logger } from "./logger";
import * as MD from "./markdown";
import type { DiagnosticLevel, OutcomeConclusion, Outcomes } from "./outcomes";
import {
  categorizeOutcome,
  countDiagnosticLevels,
  getNewDiagnostics,
  getReason,
  sortDiagnostics,
} from "./outcomes";

const COMMENT_TITLE = MD.Heading(
  `${MD.Symbol.HeavyAsterisk} Stainless preview builds`,
);

const COMMENT_FOOTER_DIVIDER = MD.Comment("stainless-preview-footer");

type PrintCommentOptions = {
  noChanges: boolean;
  orgName: string;
  projectName: string;
  branch: string;
  commitMessage: string;
  commitMessages?: Record<string, string>;
  hasAiCommitMessageMap?: Record<string, boolean>;
  baseOutcomes?: Outcomes | null;
  outcomes: Outcomes;
};

export function printComment({
  noChanges,
  orgName,
  projectName,
  branch,
  commitMessage,
  commitMessages,
  hasAiCommitMessageMap,
  baseOutcomes,
  outcomes,
}:
  | ({ noChanges?: never } & Omit<PrintCommentOptions, "noChanges">)
  | ({ noChanges: true } & {
      [K in keyof Omit<PrintCommentOptions, "noChanges">]?: never;
    })) {
  const Blocks = (() => {
    if (noChanges) {
      return "No changes were made to the SDKs.";
    }
    // Can edit if this is a preview comment (and thus baseOutcomes exist).
    // Otherwise, this is post-merge and editing it won't do anything.
    const canEdit = !!baseOutcomes;

    const hasMultipleCommitMessages =
      commitMessages && Object.keys(commitMessages).length > 0;

    if (hasMultipleCommitMessages) {
      return [
        MD.Dedent`
          This ${getPRTerm()} will update the ${MD.CodeInline(
            projectName,
          )} SDKs with the following commit messages.
        `,
        CommitMessagesSection({
          commitMessages,
          hasAiCommitMessageMap,
          outcomes,
        }),
        canEdit
          ? "Edit this comment to update them. They will appear in their respective SDK's changelogs."
          : null,
        Results({ orgName, projectName, branch, outcomes, baseOutcomes }),
      ]
        .filter((f): f is string => f !== null)
        .join(`\n\n`);
    }

    // Default: single shared commit message
    return [
      MD.Dedent`
        This ${getPRTerm()} will update the ${MD.CodeInline(
          projectName,
        )} SDKs with the following commit message.

        ${MD.CodeBlock(commitMessage)}

        ${
          canEdit
            ? "Edit this comment to update it. It will appear in the SDK's changelogs."
            : ""
        }
      `,
      Results({ orgName, projectName, branch, outcomes, baseOutcomes }),
    ]
      .filter((f): f is string => f !== null)
      .join(`\n\n`);
  })();

  const dateString = new Date()
    .toISOString()
    .replace("T", " ")
    .replace(/\.\d+Z$/, " UTC");

  const fullComment = MD.Dedent`
    ${COMMENT_TITLE}

    ${Blocks}

    ${MD.Rule()}

    ${COMMENT_FOOTER_DIVIDER}

    ${MD.Italic(
      `This comment is auto-generated by ${getCITerm()} and is automatically kept up to date as you push.<br/>` +
        `If you push custom code to the preview branch, ${MD.Link({
          text: `re-run this workflow`,
          href: getRunUrl(),
        })} to update the comment.` +
        `<br/>Last updated: ${dateString}`,
    )}
  `;

  return fullComment;
}

function CommitMessagesSection({
  commitMessages,
  hasAiCommitMessageMap,
  outcomes,
}: {
  commitMessages: Record<string, string>;
  hasAiCommitMessageMap?: Record<string, boolean>;
  outcomes: Outcomes;
}): string {
  const languages = Object.keys(outcomes).sort();

  const messageBlocks = languages.map((lang) => {
    const message = commitMessages[lang] || "No changes detected";

    // If we're still generating an AI commit message for this SDK, show a loading indicator
    const isGeneratingAiCommitMessage =
      hasAiCommitMessageMap != null && !hasAiCommitMessageMap[lang];

    const statusText = isGeneratingAiCommitMessage
      ? `${MD.Symbol.HourglassFlowingSand} (generating...)\n`
      : "";

    return MD.Dedent`
      **${lang}**
      ${statusText}${MD.CodeBlock(message)}
    `;
  });

  return messageBlocks.join("\n");
}

const DiagnosticIcon: Record<DiagnosticLevel, string> = {
  fatal: MD.Symbol.Exclamation,
  error: MD.Symbol.Exclamation,
  warning: MD.Symbol.Warning,
  note: MD.Symbol.Bulb,
};

function Results({
  orgName,
  projectName,
  branch,
  outcomes,
  baseOutcomes,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  outcomes: Outcomes;
  baseOutcomes?: Outcomes | null;
}): string {
  const results: string[] = [];
  let hasPending = false;

  // Process each outcome
  Object.entries(outcomes).forEach(([lang, head]) => {
    const base = baseOutcomes?.[lang];

    // Check if this outcome is pending
    hasPending ||=
      categorizeOutcome({
        outcome: head,
        baseOutcome: base,
      }).isPending ?? false;

    // Get the formatted result for this outcome
    const result = Result({
      orgName,
      projectName,
      branch,
      lang,
      head,
      base,
    });

    if (result) {
      results.push(result);
    }
  });

  // Add pending message if any outcomes are pending
  if (hasPending) {
    results.push(
      MD.Dedent`
        ${MD.Symbol.HourglassFlowingSand} These are partial results; builds are still running.
      `,
    );
  }

  return results.join("\n\n");
}

export function Result({
  orgName,
  projectName,
  branch,
  lang,
  head,
  base,
  hasDiff,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  lang: string;
  head: Outcomes[string];
  base?: Outcomes[string];
  hasDiff?: boolean;
}): string | null {
  const categorized = categorizeOutcome({
    outcome: head,
    baseOutcome: base,
  });

  const { ResultIcon, Description } = (() => {
    if (categorized.isPending) {
      return {
        ResultIcon: MD.Symbol.HourglassFlowingSand,
        Description: "",
      };
    }

    const { severity, conclusion, isRegression, description } = categorized;
    const reason = getReason({
      description,
      isRegression,
    });

    if (isRegression !== false && severity === "fatal") {
      return {
        ResultIcon: MD.Symbol.Exclamation,
        Description: MD.Italic(reason),
      };
    }
    if (isRegression !== false && conclusion === "merge_conflict") {
      return {
        ResultIcon: MD.Symbol.Zap,
        Description: [
          MD.Italic(reason),
          MD.Italic(
            `You don't need to resolve this conflict right now, but you will need to resolve it for your changes to be released to your users. ` +
              `Read more about why this happened ${MD.Link({
                text: "here",
                href: "https://www.stainless.com/docs/guides/add-custom-code",
              })}.`,
          ),
        ].join("\n"),
      };
    }
    if (isRegression !== false && severity !== "note" && severity !== null) {
      return {
        ResultIcon: MD.Symbol.Warning,
        Description: MD.Italic(reason),
      };
    }
    return {
      ResultIcon: MD.Symbol.WhiteCheckMark,
      Description: MD.Italic(reason),
    };
  })();

  const diffIndicator = hasDiff ? ` ${MD.Symbol.Eyes}` : "";
  return MD.Details({
    summary: [
      ResultIcon,
      MD.Bold(`${projectName}-${lang}`) + diffIndicator,

      [
        MD.Link({
          text: "studio",
          href: `https://app.stainless.com/${orgName}/${projectName}/studio?language=${lang}&branch=${branch}`,
        }),
        GitHubLink(head),
        base && hasDiff !== false ? CompareLink(base, head) : null,
        MergeConflictLink(head),
      ]
        .filter((link): link is string => link !== null)
        .join(` ${MD.Symbol.MiddleDot} `),
    ].join(" "),
    body: [
      Description,
      StatusLine(base, head),
      InstallationDetails(head, lang),
      base ? DiagnosticsDetails(head, base) : null,
    ]
      .filter((value): value is NonNullable<typeof value> => Boolean(value))
      .join("\n"),
    open:
      !categorized.isPending &&
      categorized.isRegression !== false &&
      categorized.severity !== "note" &&
      categorized.severity !== null,
  });
}

function StatusLine(
  base: Outcomes[string] | undefined,
  head: Outcomes[string],
): string {
  return [
    StatusStep(base, head, "generate"),
    StatusStep(base, head, "build"),
    StatusStep(base, head, "lint"),
    StatusStep(base, head, "test"),
  ]
    .filter((value): value is NonNullable<typeof value> => Boolean(value))
    .join(` ${MD.Symbol.RightwardsArrow} `);
}

function StatusStep(
  base: Outcomes[string] | undefined,
  head: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
): string | null {
  let baseStatus = base ? StatusSymbol(base, step) : null;
  let headStatus = StatusSymbol(head, step);

  if (!headStatus) {
    return null;
  }

  // If one of them is pending, both of them should look pending:
  if (
    baseStatus === MD.Symbol.HourglassFlowingSand ||
    headStatus === MD.Symbol.HourglassFlowingSand
  ) {
    baseStatus = MD.Symbol.HourglassFlowingSand;
    headStatus = MD.Symbol.HourglassFlowingSand;
  }

  const headText = MD.CodeInline(`${step} ${headStatus}`);
  const headURL = StatusURL(head, step);
  const headLink = headURL
    ? MD.Link({ text: headText, href: headURL })
    : headText;

  if (!baseStatus || baseStatus === headStatus) {
    return headLink;
  }

  const baseText = MD.CodeInline(`${step} ${baseStatus}`);
  const baseURL = StatusURL(base!, step);
  const baseLink = baseURL
    ? MD.Link({ text: baseText, href: baseURL })
    : baseText;

  return `${headLink} (prev: ${baseLink})`;
}

function StatusSymbol(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
) {
  if (!outcome.commit?.completed?.commit) {
    return null;
  }

  if (step === "generate") {
    switch (outcome.commit.completed.conclusion) {
      case "fatal":
      case "error":
      case "cancelled":
        return MD.Symbol.Exclamation;
      case "merge_conflict":
        return MD.Symbol.Zap;
      case "upstream_merge_conflict":
      case "warning":
        return MD.Symbol.Warning;
      default:
        return MD.Symbol.WhiteCheckMark;
    }
  }

  const stepData = outcome[step];
  if (!stepData) {
    return null;
  }

  if (stepData.status === "completed") {
    return stepData.completed.conclusion === "success"
      ? MD.Symbol.WhiteCheckMark
      : MD.Symbol.Exclamation;
  }

  return MD.Symbol.HourglassFlowingSand;
}

function StatusURL(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
) {
  if (
    step === "generate" ||
    !outcome[step] ||
    outcome[step].status !== "completed"
  ) {
    return null;
  }

  return outcome[step]?.completed?.url;
}

function GitHubLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit?.completed?.commit) return null;

  const {
    repo: { owner, name, branch },
  } = outcome.commit.completed.commit;
  return MD.Link({
    text: "code",
    href: `${getRepoPath(owner, name)}/tree/${encodeURIComponent(branch)}`,
  });
}

function CompareLink(
  base: Outcomes[string],
  head: Outcomes[string],
): string | null {
  if (!base.commit?.completed?.commit || !head.commit?.completed?.commit) {
    return null;
  }

  const { repo } = head.commit.completed.commit;
  const baseBranch = base.commit.completed.commit.repo.branch;
  const headBranch = head.commit.completed.commit.repo.branch;
  const compareURL = `${getRepoPath(repo.owner, repo.name)}/compare/${baseBranch}..${headBranch}`;
  return MD.Link({ text: "diff", href: compareURL });
}

function MergeConflictLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit?.completed?.merge_conflict_pr) return null;

  const {
    repo: { owner, name },
    number,
  } = outcome.commit.completed.merge_conflict_pr;

  return MD.Link({
    text: "conflict",
    href: `https://github.com/${owner}/${name}/pull/${number}`,
  });
}

function DiagnosticsDetails(
  head: Outcomes[string],
  base: Outcomes[string],
): string | null {
  if (!base.diagnostics || !head.diagnostics) return null;

  const newDiagnostics = getNewDiagnostics(head.diagnostics, base.diagnostics);

  if (newDiagnostics.length === 0) return null;

  const levelCounts = countDiagnosticLevels(newDiagnostics);

  const diagnosticCounts = Object.entries(levelCounts)
    .filter(([, count]) => count > 0)
    .map(([level, count]) => `${count} ${level}`);

  const diagnosticList = sortDiagnostics(newDiagnostics)
    .slice(0, 10)
    .map((d) => `${DiagnosticIcon[d.level]} ${MD.Bold(d.code)}: ${d.message}`)
    .filter(Boolean) as string[];

  const tableRows = diagnosticList
    .map((diagnostic) => `<tr>\n<td>${diagnostic}</td>\n</tr>`)
    .join("\n");
  const tableContent = `<table>\n${tableRows}\n</table>`;

  return MD.Details({
    summary: `New diagnostics (${diagnosticCounts.join(", ")})`,
    body: tableContent,
    indent: false,
  });
}

function InstallationDetails(
  head: Outcomes[string],
  lang: string,
): string | null {
  let githubGoURL: string | null = null;
  let installation: string | null = null;

  if (head.commit?.completed.commit) {
    const { repo, sha } = head.commit.completed.commit;
    githubGoURL = `github.com/${repo.owner}/${repo.name}@${sha}`;
  }

  switch (lang) {
    case "typescript":
    case "node": {
      if (head.install_url) {
        installation = `npm install ${head.install_url}`;
      }
      break;
    }
    case "python": {
      if (head.install_url) {
        installation = `pip install ${head.install_url}`;
      }
      break;
    }
    case "go": {
      if (githubGoURL) {
        installation = `go get ${githubGoURL}`;
      }
      break;
    }
    case "java": {
      if (head.install_url) {
        installation = `Add the following URL as a Maven source: '${head.install_url}'`;
      }
      break;
    }
    case "cli": {
      if (head.install_url) {
        installation = `Download and unzip: '${head.install_url}'. On macOS, run \`xattr -d com.apple.quarantine {executable name}\`.`;
      }
      break;
    }
    default: {
      return null;
    }
  }

  if (!installation) return null;
  return MD.CodeBlock({ content: installation, language: "bash" });
}

export function parseCommitMessage(body?: string | null) {
  return body?.match(/(?<!\\)```([\s\S]*?)(?<!\\)```/)?.[1].trim() ?? null;
}

export function parseCommitMessages(
  body?: string | null,
): Record<string, string> | null {
  if (!body) {
    return null;
  }

  const commitMessages: Record<string, string> = {};

  // Match pattern: **language**\n```\ncommit message\n```
  const languageBlocks = body.matchAll(
    /\*\*([a-z_]+)\*\*\s*\n```\s*\n([\s\S]*?)\n```/g,
  );

  for (const match of languageBlocks) {
    const language = match[1];
    const message = match[2].trim();

    // Skip "No changes detected" messages
    if (message && message !== "No changes detected") {
      commitMessages[language] = message;
    }
  }

  if (Object.keys(commitMessages).length === 0) {
    return null;
  }

  return commitMessages;
}

export async function retrieveComment({
  token,
  prNumber,
}: {
  token: string;
  prNumber: number;
}) {
  const client = createVCSClient(token, prNumber);
  const comments = await client.listComments();

  const existingComment =
    comments.find((comment) => comment.body?.includes(COMMENT_TITLE)) ?? null;

  return {
    id: existingComment?.id,
    commitMessages: parseCommitMessages(existingComment?.body),
    commitMessage: parseCommitMessage(existingComment?.body),
  };
}

export async function upsertComment({
  body,
  token,
  prNumber,
  skipCreate = false,
}: {
  body: string;
  token: string;
  prNumber: number;
  skipCreate?: boolean;
}) {
  const client = createVCSClient(token, prNumber);

  logger.debug(`Upserting comment on ${getPRTerm()} #${prNumber}`);

  const comments = await client.listComments();

  const firstLine = body.trim().split("\n")[0];
  const existingComment = comments.find((comment) =>
    comment.body?.includes(firstLine),
  );

  if (existingComment) {
    logger.debug("Updating existing comment:", existingComment.id);
    await client.updateComment(existingComment.id, body);
  } else if (!skipCreate) {
    logger.debug("Creating new comment");
    await client.createComment(body);
  }
}

// Severity ordering for outcome conclusions (lower index = worse)
const ConclusionSeverity: OutcomeConclusion[] = [
  "fatal",
  "error",
  "warning",
  "note",
  "success",
];

function worstConclusion(
  a: OutcomeConclusion,
  b: OutcomeConclusion,
): OutcomeConclusion {
  return ConclusionSeverity.indexOf(a) <= ConclusionSeverity.indexOf(b) ? a : b;
}

function conclusionEmoji(conclusion: OutcomeConclusion): string {
  switch (conclusion) {
    case "fatal":
    case "error":
      return MD.Symbol.Exclamation;
    case "warning":
      return MD.Symbol.Warning;
    case "note":
    case "success":
      return MD.Symbol.WhiteCheckMark;
  }
}

export function printInternalComment(
  projects: {
    orgName: string;
    projectName: string;
    branch: string;
    outcomes: Outcomes;
    baseOutcomes: Outcomes | null;
  }[],
) {
  const blocks: string[] = [];

  for (const {
    orgName,
    projectName,
    branch,
    outcomes,
    baseOutcomes,
  } of projects) {
    const projectResults: string[] = [];
    let hasPending = false;
    let worstRegression: OutcomeConclusion = "success";
    let projectHasDiff = false;

    // show languagues with diffs first
    for (const [lang, head] of Object.entries(outcomes).sort((a, b) =>
      a[1].hasDiff === b[1].hasDiff ? 0 : a[1].hasDiff ? -1 : 1,
    )) {
      const base = baseOutcomes?.[lang];

      const categorized = categorizeOutcome({
        outcome: head,
        baseOutcome: base,
      });
      hasPending ||= categorized.isPending ?? false;

      if (!categorized.isPending && categorized.isRegression === true && categorized.severity) {
        worstRegression = worstConclusion(worstRegression, categorized.severity);
      }

      const hasDiff = head.hasDiff ?? false;
      projectHasDiff ||= hasDiff;

      const result = Result({
        orgName,
        projectName,
        branch,
        lang,
        head,
        base,
        hasDiff,
      });
      if (result) {
        projectResults.push(`<li>${result}</li>`);
      }
    }

    if (hasPending) {
      projectResults.push(
        MD.Dedent`
          ${MD.Symbol.HourglassFlowingSand} These are partial results; builds are still running.
        `,
      );
    }

    const statusEmoji = hasPending
      ? MD.Symbol.HourglassFlowingSand
      : conclusionEmoji(worstRegression);

    const diffIndicator = projectHasDiff ? ` ${MD.Symbol.Eyes}` : "";
    blocks.push(
      MD.Details({
        summary: `${statusEmoji} ${MD.Bold(`${orgName}/${projectName}`)}${diffIndicator}`,
        body: projectResults.join("\n\n"),
        indent: false,
        open: worstRegression !== "success" && worstRegression !== "note" && !hasPending,
      }),
    );
  }

  const dateString = new Date()
    .toISOString()
    .replace("T", " ")
    .replace(/\.\d+Z$/, " UTC");

  return MD.Dedent`
    ${COMMENT_TITLE}

    ${blocks.join(`\n\n`)}

    ${MD.Rule()}

    ${COMMENT_FOOTER_DIVIDER}

    ${MD.Italic(`Last updated: ${dateString}`)}
  `;
}

function areCommentsEqual(a: string, b: string) {
  // Need to ignore the timestamp lines.
  return (
    a.slice(0, a.indexOf(COMMENT_FOOTER_DIVIDER)) ===
    b.slice(0, b.indexOf(COMMENT_FOOTER_DIVIDER))
  );
}

export function commentThrottler(token: string, prNumber: number) {
  let lastComment: string | null = null;
  let lastCommentTime: Date | null = null;

  return async ({ body, force = false }: { body: string; force?: boolean }) => {
    if (
      force ||
      !lastComment ||
      !lastCommentTime ||
      (!areCommentsEqual(body, lastComment) &&
        Date.now() - lastCommentTime.getTime() > 10 * 1000) ||
      Date.now() - lastCommentTime.getTime() > 30 * 1000
    ) {
      await upsertComment({ body, token, prNumber });
      lastComment = body;
      lastCommentTime = new Date();
    }
  };
}
