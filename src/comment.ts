import * as github from "@actions/github";
import { Comments as GitHubComments } from "@stainless-api/github-internal/resources/repos/issues/comments";
import { createClient as createGitHubClient } from "@stainless-api/github-internal/tree-shakable";
import type { Stainless } from "@stainless-api/sdk";
import { Outcomes } from "./runBuilds";
import * as MD from "./markdown";

type PrintCommentOptions = {
  noChanges: boolean;
  orgName: string;
  projectName: string;
  branch: string;
  commitMessage: string;
  baseOutcomes?: Outcomes | null;
  outcomes: Outcomes;
};

export function printComment({
  noChanges,
  orgName,
  projectName,
  branch,
  commitMessage,
  baseOutcomes,
  outcomes,
}:
  | ({ noChanges?: never } & Omit<PrintCommentOptions, "noChanges">)
  | ({ noChanges: true } & {
      [K in keyof Omit<PrintCommentOptions, "noChanges">]?: never;
    })) {
  const Blocks = (() => {
    if (noChanges) {
      return "No changes were made to the SDKs.";
    }
    // Can edit if this is a preview comment (and thus baseOutcomes exist).
    // Otherwise, this is post-merge and editing it won't do anything.
    const canEdit = !!baseOutcomes;

    return [
      MD.Dedent`
        This PR will update the ${MD.CodeInline(projectName)} SDKs with the following commit message.

        ${MD.CodeBlock(commitMessage)}

        ${canEdit ? "Edit this comment to update it." : ""}
      `,
      Results({ orgName, projectName, branch, outcomes, baseOutcomes }),
    ]
      .filter((f): f is string => f !== null)
      .join(`\n\n`);
  })();

  const fullComment = MD.Dedent`
    ${COMMENT_TITLE}

    ${Blocks}

    ${MD.Rule()}

    ${MD.Italic(
      `This comment is auto-generated by GitHub Actions and is automatically kept up to date as you push.<br/>Last updated: ${new Date()
        .toISOString()
        .replace("T", " ")
        .replace(/\.\d+Z$/, " UTC")}`,
    )}
  `;

  return fullComment;
}

type DiagnosticLevel =
  Stainless.Builds.Diagnostics.DiagnosticListResponse["level"];

const DiagnosticIcon: Record<DiagnosticLevel, string> = {
  fatal: MD.Symbol.Exclamation,
  error: MD.Symbol.Exclamation,
  warning: MD.Symbol.Warning,
  note: MD.Symbol.Bulb,
};

function Results({
  orgName,
  projectName,
  branch,
  outcomes,
  baseOutcomes,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  outcomes: Outcomes;
  baseOutcomes?: Outcomes | null;
}): string {
  const results: string[] = [];
  let hasPending = false;

  // Process each outcome
  Object.entries(outcomes).forEach(([lang, head]) => {
    const base = baseOutcomes?.[lang];

    // Check if this outcome is pending
    if (categorize(head, base) === "pending") {
      hasPending = true;
    }

    // Get the formatted result for this outcome
    const result = Result({
      orgName,
      projectName,
      branch,
      lang,
      head,
      base,
    });

    if (result) {
      results.push(result);
    }
  });

  // Add pending message if any outcomes are pending
  if (hasPending) {
    results.push(
      MD.Dedent`
        ${MD.Symbol.HourglassFlowingSand} These are partial results; builds are still running.
      `,
    );
  }

  return results.join("\n\n");
}

function Result({
  orgName,
  projectName,
  branch,
  lang,
  head,
  base,
}: {
  orgName: string;
  projectName: string;
  branch: string;
  lang: string;
  head: Outcomes[string];
  base?: Outcomes[string];
}): string | null {
  const category = categorize(head, base);

  // Pending outcomes don't generate individual result blocks
  if (category === "pending") {
    return null;
  }

  const Description = (() => {
    switch (category) {
      case "failure": {
        switch (head.commit.completed?.conclusion) {
          case "fatal":
            return MD.Italic(
              "Code was not generated because there was a fatal error.",
            );
          case "timed_out":
            return MD.Italic("Timed out.");
          default:
            return MD.Italic(
              `Unknown conclusion (${MD.CodeInline(head.commit.completed?.conclusion || "unknown")}).`,
            );
        }
      }
      case "merge_conflict":
        return [
          head.commit.completed?.conclusion === "upstream_merge_conflict"
            ? MD.Italic(
                `There was an upstream conflict which is preventing the preview of your change.`,
              )
            : MD.Italic(
                `There was a conflict between your custom code and your generated changes.`,
              ),

          MD.Italic(
            `You don't need to resolve this conflict right now, but you will need to resolve it for your changes to be released to your users. ` +
              `Read more about why this happened ${MD.Link({ text: "here", href: "https://www.stainless.com/docs/guides/add-custom-code" })}.`,
          ),
        ].join("\n");
      case "regression": {
        return MD.Italic("There was a regression in your SDK.");
      }
      case "success": {
        return MD.Italic("Your SDK built successfully.");
      }
      default:
        return "";
    }
  })();

  return MD.Details({
    summary: [
      ResultIcon(category),
      MD.Bold(`${projectName}-${lang}`),

      [
        MD.Link({
          text: "studio",
          href: `https://app.stainless.com/${orgName}/${projectName}/studio?language=${lang}&branch=${branch}`,
        }),
        GitHubLink(head),
        base ? CompareLink(base, head) : null,
        category === "merge_conflict"
          ? MD.Link({ text: "conflict", href: "#" })
          : null,
      ]
        .filter((link): link is string => link !== null)
        .join(` ${MD.Symbol.MiddleDot} `),
    ].join(" "),
    body: [
      Description,
      StatusLine(head),
      base ? DiagnosticsDetails(head, base) : null,
      InstallationDetails(head, lang),
    ]
      .filter((value): value is NonNullable<typeof value> => Boolean(value))
      .join("\n"),
    open: category !== "success",
  });
}

function ResultIcon(category: OutcomeCategory): string {
  switch (category) {
    case "failure":
      return MD.Symbol.Exclamation;
    case "merge_conflict":
    case "regression":
      return MD.Symbol.Warning;
    case "success":
      return MD.Symbol.WhiteCheckMark;
    default:
      return MD.Symbol.HourglassFlowingSand;
  }
}

function StatusLine(outcome: Outcomes[string]): string {
  return [
    StatusStep(outcome, "generate"),
    StatusStep(outcome, "lint"),
    StatusStep(outcome, "test"),
    StatusStep(outcome, "build"),
  ]
    .filter((value): value is NonNullable<typeof value> => Boolean(value))
    .join(` ${MD.Symbol.RightwardsArrow} `);
}

function StatusStep(
  outcome: Outcomes[string],
  step: "generate" | "lint" | "test" | "build",
): string | null {
  if (step === "generate") {
    let status: string;
    switch (outcome.commit.completed?.conclusion) {
      case "fatal":
        status = MD.Symbol.Exclamation;
        break;
      case "merge_conflict":
      case "upstream_merge_conflict":
        status = MD.Symbol.Warning;
        break;
      default:
        status = MD.Symbol.WhiteCheckMark;
        break;
    }
    const text = MD.CodeInline(`${step} ${status}`);
    const url = outcome.commit.completed?.url;
    return url ? MD.Link({ text, href: url }) : text;
  }

  const stepData = outcome[step];
  if (!stepData) {
    return null;
  }

  if (stepData.status === "completed") {
    const status =
      stepData.completed.conclusion === "success"
        ? MD.Symbol.WhiteCheckMark
        : MD.Symbol.Exclamation;
    const text = MD.CodeInline(`${step} ${status}`);
    const url = stepData.completed.url;
    return url ? MD.Link({ text, href: url }) : text;
  }

  return MD.CodeInline(`${step} ${MD.Symbol.HourglassFlowingSand}`);
}

type OutcomeCategory =
  | "failure"
  | "merge_conflict"
  | "regression"
  | "success"
  | "pending";

function GitHubLink(outcome: Outcomes[string]): string | null {
  if (!outcome.commit.completed?.commit) return null;

  const {
    repo: { owner, name, branch },
  } = outcome.commit.completed.commit;
  return MD.Link({
    text: "code",
    href: `https://github.com/${owner}/${name}/tree/${encodeURIComponent(branch)}`,
  });
}

function CompareLink(
  base: Outcomes[string],
  head: Outcomes[string],
): string | null {
  if (!base.commit.completed?.commit || !head.commit.completed?.commit) {
    return null;
  }

  const { repo } = head.commit.completed.commit;
  const baseBranch = base.commit.completed.commit.repo.branch;
  const headBranch = head.commit.completed.commit.repo.branch;
  const compareURL = `https://github.com/${repo.owner}/${repo.name}/compare/${baseBranch}..${headBranch}`;
  return MD.Link({ text: "diff", href: compareURL });
}

function DiagnosticsDetails(
  head: Outcomes[string],
  base: Outcomes[string],
): string | null {
  if (!base.diagnostics || !head.diagnostics) return null;

  const newDiagnostics = head.diagnostics.filter(
    (d) =>
      !base.diagnostics.some(
        (bd) =>
          bd.code === d.code &&
          bd.message === d.message &&
          bd.config_ref === d.config_ref &&
          bd.oas_ref === d.oas_ref,
      ),
  );

  if (newDiagnostics.length === 0) return null;

  const levelCounts: Record<DiagnosticLevel, number> = {
    fatal: 0,
    error: 0,
    warning: 0,
    note: 0,
  };

  for (const d of newDiagnostics) {
    levelCounts[d.level]++;
  }

  const diagnosticCounts = Object.entries(levelCounts)
    .filter(([, count]) => count > 0)
    .map(([level, count]) => `${count} ${level}`);

  const diagnosticList = newDiagnostics
    .slice(0, 10)
    .map((d) => {
      if (d.level === "note") {
        return null;
      }
      return `${DiagnosticIcon[d.level]} ${MD.Bold(d.code)}: ${d.message}`;
    })
    .filter(Boolean) as string[];

  const tableRows = diagnosticList
    .map((diagnostic) => `<tr>\n<td>${diagnostic}</td>\n</tr>`)
    .join("\n");
  const tableContent = `<table>\n${tableRows}\n</table>`;

  return MD.Details({
    summary: `New diagnostics (${diagnosticCounts.join(", ")})`,
    body: tableContent,
    indent: false,
  });
}

function InstallationDetails(
  head: Outcomes[string],
  lang: string,
): string | null {
  if (!head.commit.completed.commit) {
    return null;
  }

  const { repo } = head.commit.completed.commit;
  const githubURL = `https://github.com/${repo.owner}/${repo.name}.git#${repo.branch}`;

  let installation: string | null = null;
  switch (lang) {
    case "typescript":
    case "node": {
      installation = `npm install ${githubURL}`;
      break;
    }
    case "python": {
      installation = `pip install git+${githubURL}`;
      break;
    }
    default: {
      return null;
    }
  }

  return MD.Details({
    summary: "Installation",
    body: MD.CodeBlock({ content: installation, language: "bash" }),
    indent: false,
  });
}

const COMMENT_TITLE = MD.Heading(
  `${MD.Symbol.HeavyAsterisk} Stainless SDK previews`,
);

function categorize(
  head: Outcomes[string],
  base?: Outcomes[string],
): OutcomeCategory {
  // Check for fatal failures first
  switch (head.commit.completed?.conclusion) {
    case "fatal":
    case "timed_out":
      return "failure";
    case "merge_conflict":
    case "upstream_merge_conflict":
      return "merge_conflict";
  }

  // If not a completed success outcome, skip categorization
  if (
    !["error", "warning", "note", "success"].includes(
      head.commit.completed?.conclusion || "",
    )
  ) {
    return "pending";
  }

  // Check for pending steps
  for (const step of ["build", "lint", "test"] as const) {
    const stepData = head[step];
    if (stepData && stepData.status !== "completed") {
      return "pending";
    }
  }

  // Check if any step failed that previously succeeded or didn't exist
  for (const check of ["build", "lint", "test"] as const) {
    if (
      (!base?.[check] ||
        (base[check]?.status === "completed" &&
          base[check]?.completed.conclusion === "success")) &&
      head[check] &&
      head[check].status === "completed" &&
      head[check].completed.conclusion === "failure"
    ) {
      return "regression";
    }
  }

  // Check for new diagnostics that indicate regression
  if (base?.diagnostics && head.diagnostics) {
    const newDiagnostics = head.diagnostics.filter(
      (d) =>
        !base.diagnostics.some(
          (bd) =>
            bd.code === d.code &&
            bd.message === d.message &&
            bd.config_ref === d.config_ref &&
            bd.oas_ref === d.oas_ref,
        ),
    );

    if (
      newDiagnostics.some((d) =>
        ["fatal", "error", "warning"].includes(d.level),
      )
    ) {
      return "regression";
    }
  }

  return "success";
}

export function parseCommitMessage(body?: string | null) {
  return body?.match(/(?<!\\)```([\s\S]*?)(?<!\\)```/)?.[1].trim() ?? null;
}

export async function retrieveComment({ token }: { token: string }) {
  const client = createGitHubClient({
    authToken: token,
    owner: github.context.repo.owner,
    repo: github.context.repo.repo,
    resources: [GitHubComments],
  });

  const { data: comments } = await client.repos.issues.comments.list(
    github.context.issue.number,
  );

  const existingComment =
    comments.find((comment) => comment.body?.includes(COMMENT_TITLE)) ?? null;

  return {
    id: existingComment?.id,
    commitMessage: parseCommitMessage(existingComment?.body),
  };
}

export async function upsertComment({
  body,
  token,
  skipCreate = false,
}: {
  body: string;
  token: string;
  skipCreate?: boolean;
}) {
  const client = createGitHubClient({
    authToken: token,
    owner: github.context.repo.owner,
    repo: github.context.repo.repo,
    resources: [GitHubComments],
  });

  console.log("Upserting comment on PR:", github.context.issue.number);

  const { data: comments } = await client.repos.issues.comments.list(
    github.context.issue.number,
  );

  const firstLine = body.trim().split("\n")[0];
  const existingComment = comments.find((comment) =>
    comment.body?.includes(firstLine),
  );

  if (existingComment) {
    console.log("Updating existing comment:", existingComment.id);
    await client.repos.issues.comments.update(existingComment.id, { body });
  } else if (!skipCreate) {
    console.log("Creating new comment");
    await client.repos.issues.comments.create(github.context.issue.number, {
      body,
    });
  }
}
